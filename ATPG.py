import copy

# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13xKry6-oOGU1w_UMxYhojnopNWvF9xAQ
"""

run_ls = 0

class Net:
    def __init__(self, name):
        self.name= name
        self.prev=[]
        self.next=[]

global nodes_created
nodes_created = -1

path_to_file = 'input4.txt'      ## input file path

######################################## node class

class Node:

    def give_controlling_value(self,gate):
      if gate == 'OR':
        return '1'
      elif gate == 'AND':
        return '0'
      else:
        return '0'                          ## works for ID

    def give_level(self,input_nodes):
      if len(input_nodes)>0:
        return max([input_node.level for input_node in input_nodes])+1
      else:
        return -1

    def __init__(self, gate, inversion_parity, num_input, num_output, input_nodes, value= -1, level = -1):
      global nodes_created
      nodes_created+=1
      self.node_num = nodes_created
      self.gate = gate
      self.control_val = self.give_controlling_value(self.gate)
      self.inversion_parity = inversion_parity
      self.num_input = num_input
      self.num_output = num_output
      self.input_nodes = input_nodes
      self.output_nodes = []
      # self.output_nodes = output_nodes
      self.value = value
      if level<0:
        self.level = self.give_level(input_nodes)
      else:
        self.level = level

    def add_ouput(self, n):
      self.output_nodes.append(n)

    def evaluate_output(self):
        input_signal = [input_node.value for input_node in self.input_nodes]

    #   print(self.gate,self.control_val)
    #   print(input_signal)
        if self.gate != 'ID':
            if self.control_val in input_signal:
                self.value = self.control_val
            elif 'x' in input_signal:
                self.value = 'x'
            else:
                self.value = str(1-int(self.control_val))
        else:
            if input_signal[0] == 'x' or int(input_signal[0])>=0:
                self.value = input_signal[0]


    #   print(self.value)
        if self.inversion_parity == 1:
            if self.value != 'x':
                self.value = str(1-int(self.value))
    #   print(self.value)
      # print(self.node_num,self.value)

######################################### defining functions


def base_gate(op):
  op = op.lower()
  if op.endswith('and'):
    return 'AND'
  elif op.endswith('or'):
      return 'OR'
  elif op == 'not' or op== 'id':
    return 'ID'
  else:
    print("incorrect operator")
    return

def parity(op):
  op = op.lower()
  if op.startswith('n'):
    return 1
  else:
    return 0

############################################ read the architecture of the gates and implement it

nodes_created = -1
n0 = Node('None',0,0,0,[])                  ### initializing

# try:
with open(path_to_file) as f:
    contents = f.read()



contents = contents.splitlines()                    ## file as string


input_str = contents[0]                             ## input vectors
output_str = contents[1]                            ##output vectors
fault_at = contents[2][7]
stuck_at = contents[2][9]

contents = contents[3:]                             ## remainiing stuff

if run_ls:
    split_index = 0
    for i in range(len(contents)):
        if contents[i].isspace() or contents[i]=='':
            split_index = i
            break

    input_seq = contents[split_index+1:]
    contents = contents[:split_index]

#################################### take the input and output nets

inputs = input_str.split(':')[1].strip().replace(' ','').split(',')         ## input nets
outputs = output_str.split(':')[1].strip().replace(' ','').split(',')       ## output nets

############################################################

global nodes
nodes = []                      ## array of node object

global map1
map1 = {}                ## map from netlist to node whose output the netlist is
global pi_values
pi_values = {}
global stack
stack = []

node_counter = 0

global netlist_map
netlist_map = {}

############################################## makes input nodes and input nets

for i in inputs:
  n = Node('ID',0,1,0,[n0],value = 0)
  nodes.append(n)

  map1[i] = node_counter
  pi_values[i] = 'x'
  node_counter+=1

  net = Net(i)
  netlist_map[i] = net

############################################## makes netlist diagram, netlist graph

for line in contents:
  # print(line)


  line = line.strip()

  lhs,rhs = line.split('=')
  rhs = rhs.strip()

  op,inp = rhs.split(" ",1)
  op = op.strip()

  inp = inp.strip()
  inp = inp.replace(" ","")
  inp = inp.split(',')

  lhs = lhs.strip()
  lhs = lhs.replace(" ","")
  out = lhs.split(',')


  n = Node(base_gate(op), parity(op), len(inp), 0, [nodes[map1[input]] for input in inp])
  nodes.append(n)
  for o in out:
    map1[o] = node_counter

    net = Net(o)
    netlist_map[o] = net

    for i in inp:
        netlist_map[i].next.append(o)
        netlist_map[o].prev.append(i)

  node_counter+=1


if run_ls:
    ############################# stores input sequence

    value_map = {}

    for line in input_seq:
        char,value_seq = line.split(':')
        char = char.strip()
        value_seq = value_seq.strip()

        value_map[char] = value_seq

        seq_length = len(value_map[list(value_map.keys())[0]])

        out_value_map = {}

    for out_char in outputs:
        out_value_map[out_char] = ''

    ######################## generates output

    for time in range(seq_length):
    # print(time)

        for input_char in inputs:
            nodes[map1[input_char]].value = value_map[input_char][time]
            print(input_char,value_map[input_char][time])

        for n in nodes:
            n.evaluate_output()

        for out_char in outputs:
            out_value_map[out_char] = out_value_map[out_char]+str(nodes[map1[out_char]].value)

        # print(out_value_map)

        output_lines = [key+': '+out_value_map[key]+'\n' for key in out_value_map.keys()]
        # print(output_lines)

    with open('output.txt', 'w') as f:
        f.writelines(output_lines)

# except:
  # print("Your input format is wrong. Please follow the format given in readme.txt")

############################################

def logic_simulator(out_char):
    global nodes, map1, pi_values

    for input_char in pi_values.keys():
        nodes[map1[input_char]].value = pi_values[input_char]

    for n in nodes:                                                         ## run logic simulator
        n.evaluate_output()

    return nodes[map1[out_char]].value


def dfs(node, inversions,sa,sa_node):
    #### base case
    global netlist_map,pi_values,stack

    if len(netlist_map[node].prev) == 0:
        # if pi_values[node] == 'x':                                                        #######
        if node not in [n[0] for n in stack]:
            ##### run logic simulator
            if inversions%2:
                value = sa
            else:
                value = str(1-int(sa))

            pi_values[node] = value
            stack.append((node,value))
            value_at_sa = logic_simulator(sa_node)

            if value_at_sa == 'x':
                return False
            elif value_at_sa == sa:
                op_file.write("No test vector possible")
                print("No test vector possible")
                exit()
            else:
                #print(pi_values)   hii
                return True

    else:
        if nodes[map1[node]].inversion_parity:
            inversions+=1

        for prevs in netlist_map[node].prev:
            if dfs(prevs,inversions,sa,sa_node):
                return True

        return False

def tracingFromSA(sa, net):
    #### sa is a string, net is a string
    inversions = 0
    found = dfs(net,inversions,sa,net)
    # print(found)
    return found

# def valueChangeOfWrt(nexts,f):
#     logic_simulator(nexts)
#     nodes[map1[f]].value == 'x'
#     nodes[map1[nexts]].evaluate_output
#     return nodes[map1[nexts]].value



def dfs2(node, inversions,sa,sa_node):
    #### base case
    global netlist_map,pi_values,stack

    if len(netlist_map[node].prev) == 0:
        # print('nul')
        # if pi_values[node] == 'x':                                                        #######
        if node not in [n[0] for n in stack]:
            ##### run logic simulator
            if inversions%2:
                value = sa
            else:
                value = str(1-int(sa))
            # print(node,value,inversions)
            pi_values[node] = value
            stack.append((node,value))
            value_at_sa = logic_simulator(sa_node)

            if value_at_sa == 'x':
                return False
            elif value_at_sa == sa:
                return False                                                    ### change it
                # print("No test vector possible")
                # exit()
            else:
                print(pi_values)
                return True

    else:
        if nodes[map1[node]].inversion_parity:
            inversions+=1

        for prevs in netlist_map[node].prev:
            if dfs(prevs,inversions,sa,sa_node):
                return True

        return False

def tracingFromNonSA(sa, net):
    #### sa is a string, net is a string
    inversions = 0
    found = dfs2(net,inversions,sa,net)
    return found

def tracingToPO(f):
    global netlist_map, pi_values, stack,op_file

    ### base case
    if f in outputs:
        ## print the test vectors
        test_vect = [key+': '+pi_values[key]+'\n' for key in pi_values.keys()]
        op_file.writelines(test_vect)
        # exit()
        return True

    pi_values_copy = copy.deepcopy(pi_values)
    stack_copy = copy.deepcopy(stack)
    found = False
    for nexts in netlist_map[f].next:
        pi_values = copy.deepcopy(pi_values_copy)
        stack = copy.deepcopy(stack)
        # if valueChangeOfWrt(nexts,f,pi_values):             ## Check if it is a in G list
        if len(netlist_map[nexts].prev)>1:
            for pres in netlist_map[nexts].prev:
                if pres != f:
                    # print(pi_values)
                    v = logic_simulator(pres)
                    # print(pres)
                    # print(v)
                    if v == 'x':
                        # print('x')
                        if tracingFromNonSA(nodes[map1[nexts]].control_val,pres):
                            # print(pi_values)
                            # print('y')
                            found = found or tracingToPO(nexts)
                    elif v == nodes[map1[pres]].control_val:
                        # print('cv')
                        break
                    else:
                        found = found or tracingToPO(nexts)
        else:
            found = found or tracingToPO(nexts)


    return found

global last_stack_action_was_pop
last_stack_action_was_pop = 0

def stack_func():
    global last_stack_action_was_pop

    if last_stack_action_was_pop:
        latest = stack.pop()
        new = (latest[0],str(1-int(latest[1])))
        stack.append(new)
        last_stack_action_was_pop = 0
    else:
        stack.pop()
        last_stack_action_was_pop = 0

def findTVfor(sa,f):
    if not tracingFromSA(sa,f):
        print("No test vector is possible.")
        exit()

    # print('hi')
    if not tracingToPO(f):
        # print('stack')
        stack_func()
        findTVfor(sa,f)



op_file = open("output4.txt","w")
frm_fault = True
findTVfor(stuck_at,fault_at)
op_file.close()
